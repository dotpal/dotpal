<!DOCTYPE html>
<html>
<body>
	<style>
	.bubble {
		position: fixed;
		text-align: center;
		align-items: center;
		background-image: url('bubble.png');
		background-size: 100%;
	}
</style>
</body>
<script>
	'use strict'

	let debug = {}
	{
		debug.point = function(x, y) {
		}

		debug.clear = function() {
		}
	}

	let logic = {}
	{
		let is = function(v) {
			return v != null
		}
		logic.is = is

		let and = function(a, b) {
			if (is(a) && is(b)) return b
		}
		logic.and = and

		let or = function(a, b) {
			if (is(a)) return a
			else if (is(b)) return b
		}
		logic.or = or
	}

	let spring = {}
	{
		let cos = Math.cos
		let sin = Math.sin
		let exp = Math.exp
		let sqrt = Math.sqrt

		spring.new = function(p, v, k, d) {
			let self = {}

			let t = 0

			self.step = function(dt) {
				t += dt
			}

			self.update = function(t1) {
				t = t1
			}

			self.evaluate = function() {
				let h = sqrt(1 - d*d)
				let t = t*h*k // not really correct but whatever
				let s = sin(t)
				let c = h*cos(t) // not really c, more like hc
				let y = h*exp(d*t/h) // more like hy i guess
				// assuming k > 0 && d < 1
				return [b + (k*(p - b)*(c + d*s) + v*s)/(k*y), (k*(b - p)*s + v*(c - d*s))/y]
			}

			return self
		}
	}

	// Thanks to Trey
	let zeros = {}
	{
		let sqrt = Math.sqrt
		let cbrt = Math.cbrt
		let or = logic.or
		let is = logic.is

		let err = 1e-10

		// Solve results are guaranteed real && sorted.
		let solve = function(a, b, c, d, e) {
			if (is(a) && -err < a && a < err) {
				return solve(b, c, d, e)
			}
			else if (is(e)) {
				let k = -b/(4*a)
				let p = (8*a*c - 3*b*b)/(8*a*a)
				let q = (b*b*b + 8*a*a*d - 4*a*b*c)/(8*a*a*a)
				let r = (16*a*a*b*b*c + 256*a*a*a*a*e - 3*a*b*b*b*b - 64*a*a*a*b*d)/(256*a*a*a*a*a)
				let [h0, h1, h2] = solve(1, 2*p, p*p - 4*r, -q*q)
				let s = or(h2, h0)
				if (s < err) {
					let [f0, f1] = solve(1, p, r)
					if (!is(f1) || f1 < 0) {
						return []
					}
					else {
						let [f] = sqrt(f1)
						return [k - f, k + f]
					}
				}
				else {
					let h = sqrt(s)
					let f = (h*h*h + h*p - q)/(2*h)
					if (-err < f && f < err) {
						return [k - h, k]
					}
					else {
						let [r0, r1] = solve(1, h, f)
						let [r2, r3] = solve(1, -h, r/f)
						if (is(r0) && is(r2)) {
							return [k + r0, k + r1, k + r2, k + r3]
						}
						else if (is(r0)) {
							return [k + r0, k + r1]
						}
						else if (is(r2)) {
							return [k + r2, k + r3]
						}
						else {
							return []
						}
					}
				}
			}
			else if (is(d)) {
				let k = -b/(3*a)
				let p = (3*a*c - b*b)/(9*a*a)
				let q = (2*b*b*b - 9*a*b*c + 27*a*a*d)/(54*a*a*a)
				let r = p*p*p + q*q
				let s = sqrt(r) + q
				if (-err < s && s < err) {
					//p = 0
					if (q < 0) {
						return [k + cbrt(-2*q)]
					}
					else {
						return [k - cbrt(2*q)]
					}
				}
				else {
					if (r < 0) {
						let m = sqrt(-p)
						let d = atan2(sqrt(-r), q)/3
						let u = m*cos(d)
						let v = m*sin(d)
						// sqrt(3)
						return [k - 2*u, k + u - 1.7320508*v, k + u + 1.7320508*v]
					}
					else {
						if (s < 0) {
							let m = -cbrt(-s)
							return [k + p/m - m]
						}
						else {
							let m = cbrt(s)
							return [k + p/m - m]
						}
					}
				}
			}
			else if (is(c)) {
				let k = -b/(2*a)
				let u2 = k*k - c/a
				if (u2 < 0) {
					return []
				}
				else {
					let u = sqrt(u2)
					return [k - u, k + u]
				}
			}
			else if (is(b)) {
				return [-b/a]
			}
			else {
				return []
			}
		}

		zeros.solve = solve
	}

	let cast = {}
	{
		let sqrt = Math.sqrt

		cast.get_circle_onto_circle_intersection_time = function(apx, apy, avx, avy, ar, bpx, bpy, bvx, bvy, br) {
			let avav = avx*avx + avy*avy
			let avap = avx*apx + avy*apy
			let avbv = avx*bvx + avy*bvy
			let avbp = avx*bpx + avy*bpy
			let apap = apx*apx + apy*apy
			let apbp = apx*bpx + apy*bpy
			let bvap = bvx*apx + bvy*apy
			let bvbv = bvx*bvx + bvy*bvy
			let bvbp = bvx*bpx + bvy*bpy
			let bpbp = bpx*bpx + bpy*bpy
			/*
			let a = avav + 2*avbv + bvbv
			let b = avbp - bvap + bvbp - avap
			let c = 0.25*(apap - 2*apbp + bpbp - (ar + br)*(ar + br))
			let t = zeros.solve(a, -b, c)[0]
			//if (t < 0) console.log('uhhh t < 0...')
			//*/
			let t = (-avap + avbp - bvap + bvbp - sqrt((avap - avbp + bvap - bvbp)*(avap - avbp + bvap - bvbp) - (avav + 2*avbv + bvbv)*(apap - 2*apbp + bpbp - (ar + br)*(ar + br))))/(avav + 2*avbv + bvbv)
			return t
		}
	}

	let shash = {}
	{
		shash.shash1 = function(x) {
			return x
		}

		shash.shash2 = function(x, y) {
			return x + (x + y)*(x + y + 1)/2
		}

		shash.shash3 = function(x, y, z) {
			return x + (x + y)*(x + y + 1)/2 + (x + y + z)*(x + y + z + 1)*(x + y + z + 2)/6
		}
	}

	let camera = {}
	{
		camera.px = 0
		camera.py = 0
		camera.pz = 16

		let t = 0

		{
			let sqrt = Math.sqrt
			let max = Math.max
			let min = Math.min

			let ux = -1/0
			let uy = -1/0
			let lx = +1/0
			let ly = +1/0

			camera.push_focus_region = function(x, y, r) {
				ux = max(ux, x + r)
				uy = max(uy, y + r)
				lx = min(lx, x - r)
				ly = min(ly, y - r)
			}

			camera.handle_focus_regions = function() {
				camera.px = 0.5*(lx + ux)
				camera.py = 0.5*(ly + uy)
				camera.pz = sqrt((ux - lx)*(ux - lx) + (uy - ly)*(uy - ly))

				ux = -1/0
				uy = -1/0
				lx = +1/0
				ly = +1/0
			}
		}

		let update = function(t) {
			//camera.px = 200*Math.cos(1.2*t)
			//camera.py = 300*Math.sin(t)
		}

		camera.step = function(dt) {
			t = t + dt
			update(t)
		}
	}

	let bubble = {}
	{
		let random = Math.random
		let pow = Math.pow
		let pi = Math.PI
		let min = Math.min
		let sqrt = Math.sqrt
		let exp = Math.exp
		let or = logic.or

		let bubbles = []

		bubble.new = function(px, py, vx, vy, r, text, link) {
			let self = {}

			let fx, fy

			let id = random().toString().substr(2)

			let link_element = document.createElement('a')
			link_element.href = link
			document.body.appendChild(link_element)

			let bubble_element = document.createElement('div')
			bubble_element.setAttribute('class', 'bubble')
			bubble_element.innerHTML = text
			//bubble_element.innerHTML = text.substr(1, 4)
			link_element.appendChild(bubble_element)

			let present = function() {
				let projection = window.innerHeight/camera.pz
				bubble_element.style.left = 0.5*window.innerWidth + (px - r - camera.px)*projection + 'px'
				bubble_element.style.top = 0.5*window.innerHeight + (py - r - camera.py)*projection + 'px'
				bubble_element.style.width = 2*r*projection + 'px'
				bubble_element.style.height = 2*r*projection + 'px'
				bubble_element.style.lineHeight = 2*r*projection + 'px'
				bubble_element.style.fontSize = 0.2*r*projection + 'px'
			}
			self.present = present

			self.get_geometry = function() {
				return [px, py, r]
			}

			self.set_state = function(px1, py1, vx1, vy1, r1, text1, link1) {
				px = or(px1, px)
				py = or(py1, py)
				vx = or(vx1, vx)
				vy = or(vy1, vy)
				r = or(r1, r)
				text = or(text1, text)
				link = or(link1, link)
				present()
			}

			self.set_force = function(fx1, fy1) {
				fx = fx1
				fy = fy1
			}

			self.step = function(dt) {
				/*
				// position_0
				let px0 = px
				let py0 = py
				// integrate constant acceleration to get position
				px = px + dt*vx + 0.5*dt*dt*fx
				py = py + dt*vy + 0.5*dt*dt*fy
				// d position
				let dpx = px - px0
				let dpy = py - py0
				console.log(dpx, dt*vx)
				vx = vx + dt*fx
				vy = vy + dt*fy
				// minimize intersection time in the set of all intersections
				let t = 1e12
				*/
				// double integrate constant acceleration to get position
				px = px + dt*vx + 0.5*dt*dt*fx
				py = py + dt*vy + 0.5*dt*dt*fy
				vx = vx + dt*fx
				vy = vy + dt*fy
				/*
				for (let i = bubbles.length; i--;) {
					let bubbleb = bubbles[i]
					let [px]
					let t1 = cast.get_circle_onto_circle_intersection_time(px0, py0, dpx, dpy, r)
					t = min(t1, t)
				}
				*/
				present()
			}

			self.constrict = function(sx, sy) {
				if (px > sx - r) {
					px = sx - r
					vx = 0
				}
				if (py > sy - r) {
					py = sy - r
					vy = 0
				}
				if (px < r) {
					px = r
					vx = 0
				}
				if (py < r) {
					py = r
					vx = 0
				}
			}

			self.get_state = function() {
				return [px, py, vx, vy, r, text, link]
			}

			self.destroy = function() {

			}

			bubbles.push(self)

			return self
		}

		//let k = 1024
		let k = 1

		let get_single_force = function(apx, apy, ar, bpx, bpy, br) {
			/*
			let ox = bpx - apx
			let oy = bpy - apy
			let o = sqrt(ox*ox + oy*oy) || 1
			let oux = -ox/o
			let ouy = -oy/o
			let r = ar + br
			let d = o - r
			if (o > r) {
				d = pow(d, 0.3)
				//d = max(0, d)
				return [k*oux/d, k*ouy/d]
			}
			else {
				return [k*oux, k*ouy]
			}
			*/
			/*
			let ox = bpx - apx
			let oy = bpy - apy
			let o = sqrt(ox*ox + oy*oy) || 1
			let oux = -ox/o
			let ouy = -oy/o
			let d = o
			d = pow(d, 0.3)
			//d = max(0, d)
			return [k*oux/d, k*ouy/d]
			*/
			return [-k*apx, -k*apy]
		}

		let get_acting_force = function(i0, sx, sy) {
			/*
			let sfx = 0
			let sfy = 0
			let bubble0 = bubbles[i0]
			let [px0, py0, r0] = bubble0.get_geometry()
			// Forces against other bubbles
			for (let i1 = 0; i1 < bubbles.length; ++i1) {
				if (i0 != i1) {
					let bubble1 = bubbles[i1]
					let [px1, py1, r1] = bubble1.get_geometry()
					let [fx, fy] = get_single_force(px0, py0, r0, px1, py1, r1)
					sfx += fx
					sfy += fy
				}
			}
			*/
			// Forces against walls
			/*
			{
				let [fx, fy] = get_single_force(px0, py0, r0, sx, py0, 0)
				sfx += fx
				sfy += fy
			}
			{
				let [fx, fy] = get_single_force(px0, py0, r0, px0, sy, 0)
				sfx += fx
				sfy += fy
			}
			{
				let [fx, fy] = get_single_force(px0, py0, r0, 0, py0, 0)
				sfx += fx
				sfy += fy
			}
			{
				let [fx, fy] = get_single_force(px0, py0, r0, px0, 0, 0)
				sfx += fx
				sfy += fy
			}
			*/
			// Return sum of forces
			return [sfx, sfy]
		}

		let err = 1e-4

		bubble.step = function(dt) {
			//*
			let displacements = []
			// physics step
			for (let i = bubbles.length; i--;) {
				let bubble = bubbles[i]
				//let [sfx, sfy] = get_acting_force(i, sx, sy)
				// position_0
				let [px0, py0] = bubble.get_geometry()
				let [fx0, fy0] = get_single_force(px0, py0)
				bubble.set_force(fx0, fy0)
				bubble.step(dt)
				// optionally constraint the bubble into the viewport
				//bubble.constrict(sx, sy)
				let [px, py, r] = bubble.get_geometry()
				// d position
				let dpx = px - px0
				let dpy = py - py0
				// add the displaced region to the displacement list
				displacements[i] = [px0, py0, dpx, dpy, r]
			}
			//*/
			//*
			// collision step
			for (let i = bubbles.length; i--;) {
				// minimize intersection time in the set of all intersections
				let [apx0, apy0, adpx, adpy, ar] = displacements[i]
				// we're assuming dp = v, so p0 + vt = p1 and position at t = 1 is p1, so all possible collisions lie within 0 <= t <= 1
				// but we dont need to change anything if the resulting t is more than 1, because we are not predicting the future
				let t = 1
				for (let j = bubbles.length; j--;) {
					if (j != i) {
						let [bpx0, bpy0, bdpx, bdpy, br] = displacements[j]
						let th = cast.get_circle_onto_circle_intersection_time(apx0, apy0, adpx, adpy, ar, bpx0, bpy0, bdpx, bdpy, br)
						if (th >= 0) {
							t = min(t, th) // the number which is likely to be minimized should be the first argument probably
						}
					}
				}
				// there was a collision
				if (t < 1) {
					//console.log(i, t)
					bubbles[i].set_state(apx0 + t*adpx, apy0 + t*adpy, null, null, ar)
					//console.log(bubbles[i].get_state()[2])
				}
			}
			//*/
			//*
			// more collision...
			for (let i = bubbles.length; i--;) {
				let bubble_i = bubbles[i]
				let [apx, apy, avx, avy, ar] = bubble_i.get_state()
				for (let j = bubbles.length; j--;) {
					if (j != i) {
						let bubble_j = bubbles[j]
						let [bpx, bpy, bvx, bvy, br] = bubble_j.get_state()
						let ox = bpx - apx
						let oy = bpy - apy
						let ol = sqrt(ox*ox + oy*oy)
						// overlapping condition
						if (ol < ar + br + err) {
							apx = bpx - ox/ol*(ar + br)
							apy = bpy - oy/ol*(ar + br)
							let ov = ox*avx + oy*avy
							//console.log(ov)
							avx -= ov*ox/ol
							avy -= ov*oy/ol
						}
					}
				}
				bubble_i.set_state(apx, apy, avx, avy)
			}
			//*/
			/*
			// og
			for (let i = bubbles.length; i--;) {
				bubbles[i].step(dt)
				bubbles[i].constrict(sx, sy)
			}
			//*/
			/*
			// idk approximate vx and vy
			let [px, py] = bubbles[i].get_state()
			bubbles[i].set_state(null, null, (px - px0)/dt, (py - py0)/dt, null)
			//*/
			// camera focus
			for (let i = bubbles.length; i--;) {
				let [px, py, vx, vy, r] = bubbles[i].get_state()
				bubbles[i].set_state(null, null, vx*exp(-dt), vy*exp(-dt))
				camera.push_focus_region(px, py, r)
			}
			camera.handle_focus_regions()
		}
	}

	{
		let random = Math.random

		for (let i = 8; i--;) {
			bubble.new(16*random() - 8, 16*random() - 8, 8*random() - 4, 8*random() - 4, 0.5 + random(), i.toString(), 'http://je.gy')
		}

		let t0 = 0.001*performance.now()
		let render = function() {
			let t = 0.001*performance.now()
			let dt = t - t0
			t0 = t
			bubble.step(dt)
			requestAnimationFrame(render)
		}
		requestAnimationFrame(render)
	}
</script>
</html>